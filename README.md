Usage:
This is an in depth OSNIT tool designed for Instagram

Installation:
```

pkg install git python -y && pip install requests stdiomask && git clone https://github.com/Yourl0calbroker/BrokerOSNIT.git $HOME/BrokerOSNIT && printf "# Define colors and formatting codes\nCYAN = '\033[96m'\nGREEN = '\033[92m'\nRED = '\033[91m'\nYELLOW = '\033[93m'\nLIGHT_YELLOW_EX = '\033[93m'\nLIGHT_BLUE_EX = '\033[94m'\nITALIC = '\033[3m'\nITALIC_OFF = '\033[23m'\n\ndef colorPrint(*args):\n    output = ''.join(args)\n    print(output + '\033[0m') \n\nimport requests\nfrom datetime import datetime\nfrom requests.exceptions import RequestException\nimport os\nimport time\nimport threading \n\ndef get_time_str():\n    return datetime.now().strftime(\"%H:%M:%S\")\n\nis_video = None\nmedia_url = None\nfile_name = None\nstop_animation = False \n\ndef animated_loading_bar(duration_seconds=15, message=\"Your_l0cal_broker\"):\n    \n    global stop_animation\n    \n    bar_length = 30\n    steps = 100\n    interval = duration_seconds / steps\n\n    print_style = \"\\r\\033[92m\" \n    \n    for i in range(steps + 1):\n        if stop_animation:\n            break\n            \n        progress = i / steps\n        filled_length = int(bar_length * progress)\n        bar = '‚ñà' * filled_length + '-' * (bar_length - filled_length)\n        \n        print(f\"{print_style}[{bar}] {int(progress * 100)}% {message}\\033[0m\", end='', flush=True)\n        time.sleep(interval)\n\n    print(\"\\r\" + \" \" * (bar_length + 20) + \"\\r\", end='', flush=True)\n    \n\ndef fetch_data(username):\n    global stop_animation\n    current_time = get_time_str()\n    colorPrint(\n        CYAN, f\"[{current_time}] \\t\",\n        GREEN, \"[INFO] \\t\\t\\b\", \n        LIGHT_YELLOW_EX, \"Fetching profile info and posts...\"\n    )\n    \n    response = None\n    \n    loading_thread = threading.Thread(target=animated_loading_bar, args=(30, \"Your_l0cal_broker\")) \n    loading_thread.start()\n    \n    try:\n        url = f\"https://www.instagram.com/api/v1/users/web_profile_info/?username={username}\"\n        headers = {\n            \"X-IG-App-ID\": \"936619743392459\",\n        }\n        response = requests.get(url, headers=headers, timeout=15)\n        \n        stop_animation = True\n        loading_thread.join() \n\n        if response.status_code != 200:\n            error_handler(response)\n            return \n\n        user_data = response.json()[\"data\"][\"user\"]\n        \n        account_type(user_data)\n        posts_found = get_posts(user_data)\n        \n        if posts_found:\n            ask_to_download()\n        \n    except RequestException as e:\n        stop_animation = True\n        loading_thread.join()\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[REQUEST] \\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Network or connection error: {e}\"\n        )\n    except Exception as e:\n        stop_animation = True\n        loading_thread.join()\n        status_code = response.status_code if response is not None else \"N/A\"\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, f\"[{status_code}] \\t\\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Failed to fetch account data: {e}\"\n        )\n\n\ndef error_handler(response):\n    current_time = get_time_str()\n    if response.status_code == 404:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            RED, \"[404] \\t\\t\\b\",\n            RED, \"[ERROR] \\t\\t\",\n            RED, \"User not found\"\n        )\n    elif response.status_code == 401:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            RED, \"[401] \\t\\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, \"Instagram added rate limit to your IP. Try again later\"\n        )\n    else:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            RED, f\"[{response.status_code}] \\t\\t\\b\",\n            RED, \"[ERROR] \\t\\t\",\n            RED, \"Something went wrong\"\n        )\n\n\ndef account_type(user_data):\n    current_time = get_time_str()\n    if user_data.get(\"is_private\"):\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            GREEN, \"[TYPE]  \\t\\b\",\n            RED, \"Private profile\\n\"\n        )\n    else:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            GREEN, \"[TYPE]  \\t\\b\",\n            RED, \"Public profile\\n\"\n        )\n\n\ndef get_posts(user_data):\n    current_time = get_time_str()\n    edges = user_data[\"edge_owner_to_timeline_media\"][\"edges\"]\n\n    if not edges:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            GREEN, \"[POST]  \\t\\b\",\n            RED, \"No posts found\"\n        )\n        return False\n    else:\n        for i, post_item in enumerate(edges, 1):\n            post_data = post_item[\"node\"]\n            post_shortcode = post_data[\"shortcode\"]\n            is_video_flag = post_data[\"is_video\"]\n            post_owner = user_data[\"username\"]\n\n            post_url = f\"https://www.instagram.com/p/{post_shortcode}/\"\n            \n            colorPrint(YELLOW, f\"++------------------------------------------------------[{i}]-----------------------------------------------------+\\n\")\n\n            if is_video_flag:\n                colorPrint(\n                    CYAN, f\"[{current_time}] \\t\",\n                    GREEN, \"[VIDEO]  \\t\\b\",\n                    LIGHT_BLUE_EX, post_url\n                )\n            else:\n                colorPrint(\n                    CYAN, f\"[{current_time}] \\t\",\n                    GREEN, \"[IMAGE]  \\t\\b\",\n                    LIGHT_BLUE_EX, post_url\n                )\n\n            colorPrint(\n                CYAN, f\"[{current_time}] \\t\",\n                GREEN, \"[OWNER] \\t\\b\",\n                LIGHT_BLUE_EX, f\"https://www.instagram.com/{post_owner}\"\n            )\n\n            tagged_edges = post_data.get(\"edge_media_to_tagged_user\", {}).get(\"edges\", [])\n            for collaborator_item in tagged_edges:\n                collaborator_username = collaborator_item[\"node\"][\"user\"][\"username\"]\n                colorPrint(\n                    CYAN, f\"[{current_time}] \\t\",\n                    GREEN, \"[COLLAB] \\t\\b\",\n                    LIGHT_BLUE_EX, f\"https://www.instagram.com/{collaborator_username}\"\n                )\n            \n            print()\n        return True\n\ndef ask_to_download():\n    print()\n    download_choice = input(\n        f\"[{get_time_str()}] \\t [PROMPT] \\t Would you like to download any of the posts listed? (y/n): \"\n    ).lower().strip()\n    \n    if download_choice in ('y', 'yes'):\n        post_url = input(\n            f\"[{get_time_str()}] \\t [PROMPT] \\t Enter the full post URL to download: \"\n        ).strip()\n        download_media(post_url)\n    else:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            GREEN, \"[INFO] \\t\\t\", \n            LIGHT_YELLOW_EX, \"Download skipped. Exiting.\"\n        )\n\ndef fetch_media_details(url):\n    global is_video, media_url, file_name\n    \n    is_video, media_url, file_name = None, None, None\n\n    parts = url.strip('/').split(\"/\")\n    \n    if len(parts) < 6 or parts[4] not in (\"p\", \"reel\"):\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[ERROR] \\t\",\n            RED, \"Invalid URL format. Check if the URL is complete.\"\n        )\n        return False\n\n    user_name = parts[3]\n    shortcode = parts[5]\n    \n    is_reel = parts[4] == 'reel'\n    file_name = f\"{user_name}-{'reel' if is_reel else 'post'}-{shortcode.replace('-', '')[:10]}{'.mp4' if is_reel else '.jpg'}\"\n    \n    colorPrint(\n        CYAN, f\"[{get_time_str()}] \\t\",\n        GREEN, \"[INFO] \\t\\t\", \n        LIGHT_YELLOW_EX, \"Fetching media link...\"\n    )\n    \n    response = None\n    try:\n        r = requests.get(\n            f\"https://www.instagram.com/api/v1/users/web_profile_info/?username={user_name}\",\n            headers={\"X-IG-App-ID\": \"936619743392459\"},\n            timeout=15\n        )\n        response = r\n\n        if r.status_code != 200:\n            error_handler(r)\n            return False\n\n        edges = r.json()[\"data\"][\"user\"][\"edge_owner_to_timeline_media\"][\"edges\"]\n        found = False\n        for edge in edges:\n            node = edge[\"node\"]\n            if node[\"shortcode\"] == shortcode:\n                is_video = node[\"is_video\"]\n                media_url = node[\"video_url\"] if is_video else node[\"display_url\"]\n                \n                if is_video and not file_name.endswith('.mp4'):\n                    file_name = file_name[:-4] + '.mp4'\n                elif not is_video and not file_name.endswith('.jpg'):\n                    file_name = file_name[:-4] + '.jpg'\n                \n                found = True\n                break\n        \n        if not found:\n            colorPrint(\n                CYAN, f\"[{get_time_str()}] \\t\",\n                RED, \"[ERROR] \\t\",\n                RED, \"Post not found in the user's latest feed. (Instagram API limitation)\"\n            )\n            return False\n\n        return True\n\n    except RequestException as e:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[REQUEST] \\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Network error during media link fetch: {e}\"\n        )\n        return False\n    except Exception as e:\n        status_code = response.status_code if response is not None else \"N/A\"\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, f\"[{status_code}] \\t\\t\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Failed to fetch media data: {e}\"\n        )\n        return False\n\n\ndef download_media(post_url):\n    global is_video, media_url, file_name\n    \n    if not fetch_media_details(post_url):\n        return\n\n    if not media_url:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[ERROR] \\t\",\n            RED, \"Could not extract media URL.\"\n        )\n        return\n\n    download_dir = \"InstaDownloads\"\n    if not os.path.exists(download_dir):\n        os.makedirs(download_dir)\n\n    colorPrint(\n        CYAN, f\"[{get_time_str()}] \\t\",\n        GREEN, \"[INFO] \\t\\t\",\n        LIGHT_YELLOW_EX, \"Starting download...\"\n    )\n    \n    try:\n        r = requests.get(\n            media_url, \n            headers={\"X-IG-App-ID\": \"936619743392459\"},\n            stream=True,\n            timeout=30\n        )\n\n        if r.status_code == 200:\n            file_path = os.path.join(download_dir, file_name)\n            with open(file_path, \"wb\") as f:\n                for chunk in r.iter_content(chunk_size=8192):\n                    f.write(chunk)\n\n            colorPrint(\n                CYAN, f\"[{get_time_str()}] \\t\",\n                GREEN, \"[SUCCESS] \\t\",\n                LIGHT_YELLOW_EX, \"Downloaded \",\n                LIGHT_BLUE_EX, ITALIC, f\"{file_name} \", ITALIC_OFF,\n                LIGHT_YELLOW_EX, f\"to {ITALIC}'{download_dir}'{ITALIC_OFF} folder\"\n            )\n        else:\n            colorPrint(\n                CYAN, f\"[{get_time_str()}] \\t\",\n                RED, f\"[{r.status_code}] \\t\\t\\b\",\n                YELLOW, \"[WARNING] \\t\",\n                RED, f\"Failed to download media from {media_url}\"\n            )\n    except RequestException as e:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[DOWNLOAD ERR] \\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Error during media download: {e}\"\n        )\n\n\ndef time():\n    return get_time_str()\n\n# if __name__ == \"__main__\":\n#     username = input(\"Enter Instagram username: \")\n#     fetch_data(username)\n" > $HOME/BrokerOSNIT/LocalOSNIT.py && chmod +x $HOME/BrokerOSNIT/BrokerOSNIT.py $HOME/BrokerOSNIT/LocalOSNIT.py && mkdir -p $HOME/bin && if ! grep -q 'export PATH="$HOME/bin:$PATH"' $HOME/.bashrc; then echo 'export PATH="$HOME/bin:$PATH"' >> $HOME/.bashrc; fi && source $HOME/.bashrc && ln -sf $HOME/BrokerOSNIT/BrokerOSNIT.py $HOME/bin/BrokerOSNIT.py && ln -sf $HOME/BrokerOSNIT/LocalOSNIT.py $HOME/bin/LocalOSNIT.py

```

Run with command 
```
BrokerOSNIT.py
```

Updating: 
```
cd BrokerOSNIT && git pull origin main
```
Important Note:

If an error is encountered with 2FA, either turn off 2FA temporarily or create a new account for use

Any errors regarding logging in for Session ID retrieval can be a result of account suspension if an account automated requests become obvious

Session ID related issues are temporary and so are activity suspensions regarding the requests for API information

If Session ID issues persists, log into the Instagram account and check for notifications regarding unusual activity and verify it was you

Install Fix If Fail
```
pkg install git python -y && pip install requests stdiomask && git clone https://github.com/Yourl0calbroker/BrokerOSNIT.git $HOME/BrokerOSNIT && printf "# Define colors and formatting codes\nCYAN = '\033[96m'\nGREEN = '\033[92m'\nRED = '\033[91m'\nYELLOW = '\033[93m'\nLIGHT_YELLOW_EX = '\033[93m'\nLIGHT_BLUE_EX = '\033[94m'\nITALIC = '\033[3m'\nITALIC_OFF = '\033[23m'\nRESET = '\033[0m'\n\ndef colorPrint(*args):\n    output = ''.join(args)\n    print(output + '\033[0m') \n\nimport requests\nfrom datetime import datetime\nfrom requests.exceptions import RequestException\nimport os\nimport time\nimport threading \n\ndef get_time_str():\n    return datetime.now().strftime(\"%H:%M:%S\")\n\nis_video = None\nmedia_url = None\nfile_name = None\nstop_animation = False \n\ndef animated_loading_bar(duration_seconds=15, message=\"Your_l0cal_broker\"):\n    \n    global stop_animation\n    \n    bar_length = 30\n    steps = 100\n    interval = duration_seconds / steps\n\n    print_style = \"\\r\\033[92m\" \n    \n    for i in range(steps + 1):\n        if stop_animation:\n            break\n            \n        progress = i / steps\n        filled_length = int(bar_length * progress)\n        bar = '‚ñà' * filled_length + '-' * (bar_length - filled_length)\n        \n        print(f\"{print_style}[{bar}] {int(progress * 100)}% {message}\\033[0m\", end='', flush=True)\n        time.sleep(interval)\n\n    print(\"\\r\" + \" \" * (bar_length + 20) + \"\\r\", end='', flush=True)\n    \n\ndef fetch_data(username):\n    global stop_animation\n    current_time = get_time_str()\n    colorPrint(\n        CYAN, f\"[{current_time}] \\t\",\n        GREEN, \"[INFO] \\t\\t\\b\", \n        LIGHT_YELLOW_EX, \"Fetching profile info and posts...\"\n    )\n    \n    response = None\n    \n    loading_thread = threading.Thread(target=animated_loading_bar, args=(30, \"Your_l0cal_broker\")) \n    loading_thread.start()\n    \n    try:\n        url = f\"https://www.instagram.com/api/v1/users/web_profile_info/?username={username}\"\n        headers = {\n            \"X-IG-App-ID\": \"936619743392459\",\n        }\n        response = requests.get(url, headers=headers, timeout=15)\n        \n        stop_animation = True\n        loading_thread.join() \n\n        if response.status_code != 200:\n            error_handler(response)\n            return \n\n        user_data = response.json()[\"data\"][\"user\"]\n        \n        account_type(user_data)\n        posts_found = get_posts(user_data)\n        \n        if posts_found:\n            ask_to_download()\n        \n    except RequestException as e:\n        stop_animation = True\n        loading_thread.join()\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[REQUEST] \\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Network or connection error: {e}\"\n        )\n    except Exception as e:\n        stop_animation = True\n        loading_thread.join()\n        status_code = response.status_code if response is not None else \"N/A\"\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, f\"[{status_code}] \\t\\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Failed to fetch account data: {e}\"\n        )\n\n\ndef error_handler(response):\n    current_time = get_time_str()\n    if response.status_code == 404:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            RED, \"[404] \\t\\t\\b\",\n            RED, \"[ERROR] \\t\\t\",\n            RED, \"User not found\"\n        )\n    elif response.status_code == 401:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            RED, \"[401] \\t\\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, \"Instagram added rate limit to your IP. Try again later\"\n        )\n    else:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            RED, f\"[{response.status_code}] \\t\\t\\b\",\n            RED, \"[ERROR] \\t\\t\",\n            RED, \"Something went wrong\"\n        )\n\n\ndef account_type(user_data):\n    current_time = get_time_str()\n    if user_data.get(\"is_private\"):\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            GREEN, \"[TYPE]  \\t\\b\",\n            RED, \"Private profile\\n\"\n        )\n    else:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            GREEN, \"[TYPE]  \\t\\b\",\n            RED, \"Public profile\\n\"\n        )\n\n\ndef get_posts(user_data):\n    current_time = get_time_str()\n    edges = user_data[\"edge_owner_to_timeline_media\"][\"edges\"]\n\n    if not edges:\n        colorPrint(\n            CYAN, f\"[{current_time}] \\t\",\n            GREEN, \"[POST]  \\t\\b\",\n            RED, \"No posts found\"\n        )\n        return False\n    else:\n        for i, post_item in enumerate(edges, 1):\n            post_data = post_item[\"node\"]\n            post_shortcode = post_data[\"shortcode\"]\n            is_video_flag = post_data[\"is_video\"]\n            post_owner = user_data[\"username\"]\n\n            post_url = f\"https://www.instagram.com/p/{post_shortcode}/\"\n            \n            colorPrint(YELLOW, f\"++------------------------------------------------------[{i}]-----------------------------------------------------+\\n\")\n\n            if is_video_flag:\n                colorPrint(\n                    CYAN, f\"[{current_time}] \\t\",\n                    GREEN, \"[VIDEO]  \\t\\b\",\n                    LIGHT_BLUE_EX, post_url\n                )\n            else:\n                colorPrint(\n                    CYAN, f\"[{current_time}] \\t\",\n                    GREEN, \"[IMAGE]  \\t\\b\",\n                    LIGHT_BLUE_EX, post_url\n                )\n\n            colorPrint(\n                CYAN, f\"[{current_time}] \\t\",\n                GREEN, \"[OWNER] \\t\\b\",\n                LIGHT_BLUE_EX, f\"https://www.instagram.com/{post_owner}\"\n            )\n\n            tagged_edges = post_data.get(\"edge_media_to_tagged_user\", {}).get(\"edges\", [])\n            for collaborator_item in tagged_edges:\n                collaborator_username = collaborator_item[\"node\"][\"user\"][\"username\"]\n                colorPrint(\n                    CYAN, f\"[{current_time}] \\t\",\n                    GREEN, \"[COLLAB] \\t\\b\",\n                    LIGHT_BLUE_EX, f\"https://www.instagram.com/{collaborator_username}\"\n                )\n            \n            print()\n        return True\n\ndef ask_to_download():\n    print()\n    download_choice = input(\n        f\"[{get_time_str()}] \\t [PROMPT] \\t Would you like to download any of the posts listed? (y/n): \"\n    ).lower().strip()\n    \n    if download_choice in ('y', 'yes'):\n        post_url = input(\n            f\"[{get_time_str()}] \\t [PROMPT] \\t Enter the full post URL to download: \"\n        ).strip()\n        download_media(post_url)\n    else:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            GREEN, \"[INFO] \\t\\t\", \n            LIGHT_YELLOW_EX, \"Download skipped. Exiting.\"\n        )\n\ndef fetch_media_details(url):\n    global is_video, media_url, file_name\n    \n    is_video, media_url, file_name = None, None, None\n\n    parts = url.strip('/').split(\"/\")\n    \n    if len(parts) < 6 or parts[4] not in (\"p\", \"reel\"):\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[ERROR] \\t\",\n            RED, \"Invalid URL format. Check if the URL is complete.\"\n        )\n        return False\n\n    user_name = parts[3]\n    shortcode = parts[5]\n    \n    is_reel = parts[4] == 'reel'\n    file_name = f\"{user_name}-{'reel' if is_reel else 'post'}-{shortcode.replace('-', '')[:10]}{'.mp4' if is_reel else '.jpg'}\"\n    \n    colorPrint(\n        CYAN, f\"[{get_time_str()}] \\t\",\n        GREEN, \"[INFO] \\t\\t\", \n        LIGHT_YELLOW_EX, \"Fetching media link...\"\n    )\n    \n    response = None\n    try:\n        r = requests.get(\n            f\"https://www.instagram.com/api/v1/users/web_profile_info/?username={user_name}\",\n            headers={\"X-IG-App-ID\": \"936619743392459\"},\n            timeout=15\n        )\n        response = r\n\n        if r.status_code != 200:\n            error_handler(r)\n            return False\n\n        edges = r.json()[\"data\"][\"user\"][\"edge_owner_to_timeline_media\"][\"edges\"]\n        found = False\n        for edge in edges:\n            node = edge[\"node\"]\n            if node[\"shortcode\"] == shortcode:\n                is_video = node[\"is_video\"]\n                media_url = node[\"video_url\"] if is_video else node[\"display_url\"]\n                \n                if is_video and not file_name.endswith('.mp4'):\n                    file_name = file_name[:-4] + '.mp4'\n                elif not is_video and not file_name.endswith('.jpg'):\n                    file_name = file_name[:-4] + '.jpg'\n                \n                found = True\n                break\n        \n        if not found:\n            colorPrint(\n                CYAN, f\"[{get_time_str()}] \\t\",\n                RED, \"[ERROR] \\t\",\n                RED, \"Post not found in the user's latest feed. (Instagram API limitation)\"\n            )\n            return False\n\n        return True\n\n    except RequestException as e:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[REQUEST] \\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Network error during media link fetch: {e}\"\n        )\n        return False\n    except Exception as e:\n        status_code = response.status_code if response is not None else \"N/A\"\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, f\"[{status_code}] \\t\\t\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Failed to fetch media data: {e}\"\n        )\n        return False\n\n\ndef download_media(post_url):\n    global is_video, media_url, file_name\n    \n    if not fetch_media_details(post_url):\n        return\n\n    if not media_url:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[ERROR] \\t\",\n            RED, \"Could not extract media URL.\"\n        )\n        return\n\n    download_dir = \"InstaDownloads\"\n    if not os.path.exists(download_dir):\n        os.makedirs(download_dir)\n\n    colorPrint(\n        CYAN, f\"[{get_time_str()}] \\t\",\n        GREEN, \"[INFO] \\t\\t\",\n        LIGHT_YELLOW_EX, \"Starting download...\"\n    )\n    \n    try:\n        r = requests.get(\n            media_url, \n            headers={\"X-IG-App-ID\": \"936619743392459\"},\n            stream=True,\n            timeout=30\n        )\n\n        if r.status_code == 200:\n            file_path = os.path.join(download_dir, file_name)\n            with open(file_path, \"wb\") as f:\n                for chunk in r.iter_content(chunk_size=8192):\n                    f.write(chunk)\n\n            colorPrint(\n                CYAN, f\"[{get_time_str()}] \\t\",\n                GREEN, \"[SUCCESS] \\t\",\n                LIGHT_YELLOW_EX, \"Downloaded \",\n                LIGHT_BLUE_EX, ITALIC, f\"{file_name} \", ITALIC_OFF,\n                LIGHT_YELLOW_EX, f\"to {ITALIC}'{download_dir}'{ITALIC_OFF} folder\"\n            )\n        else:\n            colorPrint(\n                CYAN, f\"[{get_time_str()}] \\t\",\n                RED, f\"[{r.status_code}] \\t\\t\\b\",\n                YELLOW, \"[WARNING] \\t\",\n                RED, f\"Failed to download media from {media_url}\"\n            )\n    except RequestException as e:\n        colorPrint(\n            CYAN, f\"[{get_time_str()}] \\t\",\n            RED, \"[DOWNLOAD ERR] \\t\\b\",\n            YELLOW, \"[WARNING] \\t\",\n            RED, f\"Error during media download: {e}\"\n        )\n\n\ndef time():\n    return get_time_str()\n" > $HOME/BrokerOSNIT/LocalOSNIT.py && printf "#!/usr/bin/env python3\n\"\"\"\nBrokerOSNIT.py\n\nExtended investigator version ‚Äî best-effort collection of all available data for a target Instagram\naccount using an authenticated mobile API session (sessionid). The script:\n\n- Logs into Instagram mobile API (handles 2FA) and obtains session cookies.\n- Lets you query a target username or numeric id and collects maximum available data via:\n  - web_profile_info (web_profile_info endpoint)\n  - users/{userId}/info (private API)\n  - users/lookup (advanced lookup)\n  - feed/user/{userId}/?count=... (recent media) to extract timestamps and location metadata\n  - HEAD requests to profile picture & recent media to get CDN headers (source, last-modified, size)\n- Aggregates and displays:\n  - Clean Account Summary\n  - Full raw JSONs (for inspection)\n  - Extended Investigator view: linked accounts, public contact fields, recent activity timestamps,\n    inferred last active (heuristic), media locations & probable places, profile-picture source & headers.\n- Presents an interactive menu to navigate outputs (Summary / Raw JSON / Advanced Lookup / Media / Investigator / Cookies).\n\nLimitations & Ethics:\n- This is best-effort only. Server-side obfuscation (masked emails/phones) cannot be bypassed.\n- Some endpoints may be rate-limited or return less data depending on account privacy, API changes, or session privileges.\n- Only use against accounts you own or are authorized to inspect or at least dont get caught (;\n\nDependencies:\n    pip install requests stdiomask\n    Optional: pip install phonenumbers pycountry\n\nRun:\n    python3 BrokerOSNIT.py\n\"\"\"\n\n# ==============================================================================\n# üõ†Ô∏è INTEGRATED COLOR PRINTER (REPLACING EXTERNAL UTILS DEPENDENCY)\n# ==============================================================================\n\n# Define colors and formatting codes\nCYAN = '\\033[96m'\nGREEN = '\\033[92m'\nRED = '\\033[91m'\nYELLOW = '\\033[93m'\nLIGHT_YELLOW_EX = '\\033[93m'\nLIGHT_BLUE_EX = '\\033[94m'\nITALIC = '\\033[3m'\nITALIC_OFF = '\\033[23m'\nRESET = '\\033[0m'\nCLEAR_LINE = \"\\033[K\"\n\ndef colorPrint(*args):\n    \"\"\"Prints text with colors and resets the color code.\"\"\"\n    output = ''.join(args)\n    print(output + RESET)\n\n# ==============================================================================\n\nfrom uuid import uuid4\nimport os\nimport sys\nimport re\nimport time\nimport queue\nimport threading\nimport json\nfrom datetime import datetime, timezone\n\nimport requests\nimport stdiomask\n\n# Optional libs for nicer phone/country display\ntry:\n    import phonenumbers\n    from phonenumbers.phonenumberutil import region_code_for_country_code\n    import pycountry\n    HAS_PHONE = True\nexcept Exception:\n    HAS_PHONE = False\n\n# ------------ Config ------------\nOTP_TIMEOUT = 60  # seconds to wait for 2FA code / 2FA request timeout\nANIM_BAR_LEN = 30\nANIM_STEP_DELAY = 0.12\nMESSAGE = \"Your_l0cal_broker\"\nLOGIN_URL = \"https://i.instagram.com/api/v1/accounts/login/\"\nTWO_FACTOR_URL = \"https://i.instagram.com/api/v1/accounts/login_two_factor/\"\nWEB_PROFILE_INFO = \"https://i.instagram.com/api/v1/users/web_profile_info/?username={username}\"\nUSER_INFO = \"https://i.instagram.com/api/v1/users/{user_id}/info/\"\nUSER_FEED = \"https://i.instagram.com/api/v1/feed/user/{user_id}/?count={count}\"\nLOOKUP = \"https://i.instagram.com/api/v1/users/lookup/\"\nUSERNAME_INFO = \"https://i.instagram.com/api/v1/users/{username}/usernameinfo/\"\nWWW_PROFILE_A1 = \"https://www.instagram.com/{username}/?__a=1&__d=dis\"\n# ---------------------------------\n\n# ---- utilities ----\n\ndef label_cookie_name(name):\n    n = (name or \"\").lower()\n    if any(k in n for k in (\"session\", \"sess\", \"sid\", \"sessionid\")):\n        return \"session\"\n    if any(k in n for k in (\"auth\", \"token\", \"jwt\", \"access\")):\n        return \"auth\"\n    if any(k in n for k in (\"csrf\", \"csrftoken\")):\n        return \"csrf\"\n    if any(k in n for k in (\"mid\", \"mid_\")):\n        return \"mid\"\n    if any(k in n for k in (\"ig_\", \"ds_user\")):\n        return \"instagram\"\n    if any(k in n for k in (\"lang\", \"locale\")):\n        return \"locale\"\n    return \"other\"\n\ndef animate_loading(stop_event, message=MESSAGE, bar_len=ANIM_BAR_LEN, step_delay=ANIM_STEP_DELAY):\n    pos = 0\n    width = max(3, bar_len // 4)\n    revealed = 0\n    try:\n        while not stop_event.is_set():\n            bar = [\" \"] * bar_len\n            for i in range(width):\n                idx = (pos + i) % bar_len\n                bar[idx] = \"=\"\n            pos = (pos + 1) % bar_len\n            bar_str = \"[\" + \"\".join(bar) + \"]\"\n            line1 = f\"{GREEN}{bar_str}{RESET}\"\n            if revealed < len(message):\n                revealed += 1\n            line2 = message[:revealed]\n            sys.stdout.write(\"\\r\" + CLEAR_LINE + line1 + \"\\n\" + CLEAR_LINE + line2 + \"\\n\")\n            sys.stdout.flush()\n            sys.stdout.write(\"\\033[2A\")\n            time.sleep(step_delay)\n        sys.stdout.write(\"\\r\" + CLEAR_LINE + \" \" * (bar_len + 2) + \"\\n\" + CLEAR_LINE + message + \"\\n\")\n        sys.stdout.flush()\n    except Exception:\n        stop_event.set()\n\ndef input_with_timeout(prompt, timeout, stop_event):\n    q = queue.Queue()\n    def reader(q):\n        try:\n            s = input(prompt)\n            q.put(s)\n        except Exception:\n            q.put(None)\n    th = threading.Thread(target=reader, args=(q,), daemon=True)\n    th.start()\n    try:\n        return q.get(timeout=timeout)\n    except queue.Empty:\n        stop_event.set()\n        return None\n\ndef safe_json(resp):\n    try:\n        return resp.json()\n    except Exception:\n        return {}\n\ndef pretty_print_json(obj, label=None):\n    if label:\n        print(f\"\\n--- {label} ---\")\n    try:\n        print(json.dumps(obj, indent=2, ensure_ascii=False))\n    except Exception:\n        print(str(obj))\n\ndef format_phone(public_phone_country_code, public_phone_number):\n    if not public_phone_number:\n        return None\n    try:\n        phonenr = f\"\\t+{public_phone_country_code} {public_phone_number}\" if public_phone_country_code else str(public_phone_number)\n        if HAS_PHONE:\n            pn = phonenumbers.parse(phonenr)\n            countrycode = region_code_for_country_code(pn.country_code)\n            country = pycountry.countries.get(alpha_2=countrycode)\n            return f\"{phonenr} ({country.name})\"\n        return phonenr\n    except Exception:\n        return phonenr\n\ndef head_request_headers(url, cookies=None, headers=None, timeout=15):\n    try:\n        r = requests.head(url, cookies=cookies, headers=headers or {}, timeout=timeout, allow_redirects=True)\n        return {\n            \"status_code\": r.status_code,\n            \"content_type\": r.headers.get(\"Content-Type\"),\n            \"content_length\": r.headers.get(\"Content-Length\"),\n            \"last_modified\": r.headers.get(\"Last-Modified\"),\n            \"etag\": r.headers.get(\"ETag\"),\n            \"date\": r.headers.get(\"Date\"),\n            \"server\": r.headers.get(\"Server\"),\n            \"final_url\": r.url\n        }\n    except Exception:\n        return None\n\ndef epoch_to_iso(ts):\n    try:\n        return datetime.fromtimestamp(int(ts), tz=timezone.utc).isoformat()\n    except Exception:\n        return str(ts)\n\n# ---- Instagram data collectors ----\n\ndef get_user_web_profile(username, sessionid=None):\n    url = WEB_PROFILE_INFO.format(username=username)\n    headers = {\"User-Agent\": \"Mozilla/5.0 (compatible)\", \"x-ig-app-id\": \"936619743392459\"}\n    cookies = {'sessionid': sessionid} if sessionid else None\n    try:\n        r = requests.get(url, headers=headers, cookies=cookies, timeout=15)\n    except Exception as e:\n        return {\"error\": f\"network: {e}\"}\n    if r.status_code == 404:\n        return {\"error\": \"not_found\", \"raw\": safe_json(r)}\n    return {\"raw\": safe_json(r), \"status_code\": r.status_code}\n\ndef get_user_info_private(user_id, sessionid):\n    url = USER_INFO.format(user_id=user_id)\n    headers = {\"User-Agent\": \"Instagram 64.0.0.14.96\"}\n    try:\n        r = requests.get(url, headers=headers, cookies={'sessionid': sessionid}, timeout=15)\n    except Exception as e:\n        return {\"error\": f\"network: {e}\"}\n    if r.status_code == 429:\n        return {\"error\": \"rate_limit\", \"raw\": safe_json(r)}\n    return {\"raw\": safe_json(r), \"status_code\": r.status_code}\n\ndef get_feed_media(user_id, sessionid, count=12):\n    url = USER_FEED.format(user_id=user_id, count=count)\n    headers = {\"User-Agent\": \"Instagram 64.0.0.14.96\"}\n    try:\n        r = requests.get(url, headers=headers, cookies={'sessionid': sessionid}, timeout=20)\n    except Exception as e:\n        return {\"error\": f\"network: {e}\"}\n    if r.status_code == 429:\n        return {\"error\": \"rate_limit\", \"raw\": safe_json(r)}\n    return {\"raw\": safe_json(r), \"status_code\": r.status_code}\n\ndef do_advanced_lookup(username, sessionid=None):\n    data = \"signed_body=SIGNATURE.\" + json.dumps({\"q\": username, \"skip_recovery\": \"1\"}, separators=(\",\", \":\"))\n    headers = {\n        \"Accept-Language\": \"en-US\",\n        \"User-Agent\": \"Instagram 101.0.0.15.120\",\n        \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n        \"X-IG-App-ID\": \"124024574287414\",\n    }\n    cookies = {'sessionid': sessionid} if sessionid else None\n    try:\n        r = requests.post(LOOKUP, headers=headers, data=data, cookies=cookies, timeout=15)\n    except Exception as e:\n        return {\"error\": f\"network: {e}\"}\n    try:\n        return {\"raw\": r.json(), \"status_code\": r.status_code}\n    except Exception:\n        return {\"raw_text\": r.text, \"status_code\": r.status_code}\n\ndef get_usernameinfo(username, sessionid=None):\n    url = USERNAME_INFO.format(username=username)\n    headers = {\"User-Agent\": \"Instagram 64.0.0.14.96\", \"x-ig-app-id\": \"936619743392459\"}\n    try:\n        r = requests.get(url, headers=headers, cookies={'sessionid': sessionid} if sessionid else None, timeout=15)\n    except Exception as e:\n        return {\"error\": f\"network: {e}\"}\n    return {\"status_code\": r.status_code, \"raw\": safe_json(r), \"text\": r.text}\n\ndef get_www_profile_a1(username):\n    url = WWW_PROFILE_A1.format(username=username)\n    headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\", \"Accept\": \"application/json\"}\n    try:\n        r = requests.get(url, headers=headers, timeout=15)\n    except Exception as e:\n        return {\"error\": f\"network: {e}\"}\n    return {\"status_code\": r.status_code, \"raw\": safe_json(r), \"text\": r.text}\n\n# ---- helpers for inference ----\n\ndef extract_profile_picture_info(user_raw, sessionid):\n    url_candidates = []\n    try:\n        if isinstance(user_raw, dict):\n            for path in (\n                (\"profile_pic_url_hd\",),\n                (\"profile_pic_url\",),\n                (\"hd_profile_pic_url_info\", \"url\"),\n            ):\n                cur = user_raw\n                for p in path:\n                    if cur is None:\n                        break\n                    cur = cur.get(p) if isinstance(cur, dict) else None\n                if isinstance(cur, str) and cur:\n                    url_candidates.append(cur)\n                elif isinstance(cur, dict) and cur.get(\"url\"):\n                    url_candidates.append(cur.get(\"url\"))\n    except Exception:\n        pass\n    url_candidates = [u for i, u in enumerate(url_candidates) if u and u not in url_candidates[:i]]\n    results = []\n    for u in url_candidates:\n        hdrs = head_request_headers(u, cookies={'sessionid': sessionid} if sessionid else None)\n        results.append({\"url\": u, \"head\": hdrs})\n    return results\n\ndef infer_locations_from_feed(feed_raw):\n    if not isinstance(feed_raw, dict):\n        return {\"locations\": [], \"last_post_ts\": None}\n    items = feed_raw.get(\"items\") or []\n    locations = []\n    last_post_ts = None\n    for it in items or []:\n        try:\n            loc = it.get(\"location\")\n            if loc:\n                place = {\n                    \"name\": loc.get(\"name\"),\n                    \"address\": loc.get(\"address\", \"\"),\n                    \"pk\": loc.get(\"pk\") or loc.get(\"id\"),\n                    \"lat\": loc.get(\"lat\"),\n                    \"lng\": loc.get(\"lng\")\n                }\n                locations.append(place)\n            taken = it.get(\"taken_at\") or it.get(\"device_timestamp\") or it.get(\"timestamp\")\n            if taken:\n                try:\n                    ts = int(taken)\n                except Exception:\n                    ts = None\n                if ts and (not last_post_ts or ts > last_post_ts):\n                    last_post_ts = ts\n        except Exception:\n            continue\n    uniq = []\n    seen = set()\n    for l in locations:\n        key = (l.get(\"pk\"), l.get(\"name\"))\n        if key not in seen:\n            seen.add(key)\n            uniq.append(l)\n    return {\"locations\": uniq, \"last_post_ts\": last_post_ts}\n\ndef try_get_last_active(user_raw, feed_info):\n    if isinstance(user_raw, dict):\n        for k in (\"last_activity_at\", \"last_online_time\", \"last_seen\", \"last_activity\"):\n            v = user_raw.get(k)\n            if v:\n                return v\n    if feed_info and feed_info.get(\"last_post_ts\"):\n        return epoch_to_iso(feed_info[\"last_post_ts\"])\n    return None\n\ndef gather_linked_accounts(user_raw, lookup_raw):\n    linked = {\"facebook_pages\": [], \"connected_accounts\": [], \"external_urls\": [], \"emails\": [], \"phones\": []}\n    def scan_for_keys(obj):\n        if not isinstance(obj, dict):\n            return\n        for k, v in obj.items():\n            lk = str(k).lower()\n            try:\n                if any(x in lk for x in (\"fb\", \"facebook\", \"connected\", \"connected_accounts\", \"connected_instagram\")):\n                    linked[\"connected_accounts\"].append({k: v})\n                if \"external_url\" == lk or \"external_urls\" in lk or \"external\" in lk:\n                    if isinstance(v, str) and v:\n                        linked[\"external_urls\"].append(v)\n                    elif isinstance(v, list):\n                        linked[\"external_urls\"].extend([x for x in v if isinstance(x, str)])\n                if \"public_email\" in lk or \"email\" in lk:\n                    if isinstance(v, str) and v:\n                        linked[\"emails\"].append(v)\n                if \"public_phone\" in lk or \"phone\" in lk:\n                    if isinstance(v, str) and v:\n                        linked[\"phones\"].append(v)\n                if isinstance(v, dict):\n                    scan_for_keys(v)\n                if isinstance(v, list):\n                    for e in v:\n                        if isinstance(e, dict):\n                            scan_for_keys(e)\n            except Exception:\n                continue\n    scan_for_keys(user_raw or {})\n    if isinstance(lookup_raw, dict):\n        for k, v in lookup_raw.items():\n            lk = str(k).lower()\n            if \"obfus\" in lk or \"masked\" in lk or \"hidden\" in lk:\n                linked[\"connected_accounts\"].append({k: v})\n            if \"email\" in lk and isinstance(v, str):\n                linked[\"emails\"].append(v)\n            if \"phone\" in lk and isinstance(v, str):\n                linked[\"phones\"].append(v)\n            if \"facebook\" in lk or \"fb\" in lk:\n                linked[\"facebook_pages\"].append({k: v})\n    for k in linked:\n        seen = set()\n        out = []\n        for item in linked[k]:\n            if isinstance(item, dict):\n                tup = tuple(sorted(item.items()))\n            else:\n                tup = item\n            if tup not in seen:\n                seen.add(tup)\n                out.append(item)\n        linked[k] = out\n    return linked\n\n# ---- New: robust ID resolution ----\n\ndef resolve_user_id(username, sessionid=None):\n    \"\"\"\n    Try several endpoints to resolve a username to a numeric user id (pk).\n    Returns a tuple: (user_id as str or None, source string, raw_response)\n    Sources tried (in order):\n      - i.instagram.com /web_profile_info\n      - users/lookup (advanced_lookup)\n      - i.instagram.com /usernameinfo\n      - www.instagram.com ?__a=1 public web\n    \"\"\"\n    # 1) web_profile_info\n    try:\n        res = get_user_web_profile(username, sessionid)\n        raw = res.get(\"raw\")\n        if isinstance(raw, dict):\n            # typical path: raw[\"data\"][\"user\"][\"id\"]\n            u = raw.get(\"data\", {}).get(\"user\")\n            if isinstance(u, dict):\n                pk = u.get(\"id\") or u.get(\"pk\")\n                if pk:\n                    return str(pk), \"web_profile_info\", raw\n    except Exception:\n        pass\n\n    # 2) advanced lookup (users/lookup)\n    try:\n        res = do_advanced_lookup(username, sessionid)\n        raw = res.get(\"raw\") or {}\n        # some responses nest user info or contain 'user' object\n        if isinstance(raw, dict):\n            # attempt a few common places for pk\n            #  - raw.get('user', {}).get('pk') or raw.get('user', {}).get('id')\n            user_node = None\n            if raw.get(\"user\"):\n                user_node = raw.get(\"user\")\n            # sometimes 'users' or first element exists\n            if not user_node:\n                for k in (\"users\", \"user\", \"data\"):\n                    if raw.get(k):\n                        maybe = raw.get(k)\n                        if isinstance(maybe, list) and maybe:\n                            user_node = maybe[0]\n                        elif isinstance(maybe, dict):\n                            user_node = maybe\n            if isinstance(user_node, dict):\n                pk = user_node.get(\"pk\") or user_node.get(\"id\")\n                if pk:\n                    return str(pk), \"users/lookup\", raw\n    except Exception:\n        pass\n\n    # 3) usernameinfo endpoint\n    try:\n        res = get_usernameinfo(username, sessionid)\n        raw = res.get(\"raw\")\n        if isinstance(raw, dict):\n            # path might be raw.get(\"user\", {}).get(\"pk\")\n            user_node = raw.get(\"user\") or raw\n            if isinstance(user_node, dict):\n                pk = user_node.get(\"pk\") or user_node.get(\"id\")\n                if pk:\n                    return str(pk), \"usernameinfo\", raw\n    except Exception:\n        pass\n\n    # 4) public web ?__a=1\n    try:\n        res = get_www_profile_a1(username)\n        raw = res.get(\"raw\")\n        if isinstance(raw, dict):\n            # depending on Instagram version, the structure can vary\n            # try common patterns:\n            #   raw.get(\"graphql\", {}).get(\"user\", {}).get(\"id\")\n            g = raw.get(\"graphql\") or raw.get(\"data\") or raw\n            if isinstance(g, dict):\n                u = g.get(\"user\") or g.get(\"profile\") or g\n                if isinstance(u, dict):\n                    pk = u.get(\"id\") or u.get(\"pk\")\n                    if pk:\n                        return str(pk), \"www_profile_a1\", raw\n    except Exception:\n        pass\n\n    # failed\n    return None, None, None\n\n# ---- UI / aggregation / investigator (unchanged except integration) ----\n\ndef print_account_summary(user):\n    print(\"\\n===== Account Summary =====\")\n    def p(k, label=None):\n        if k in user and user.get(k) not in (None, \"\", [], {}):\n            lbl = label or k\n            print(f\"{lbl:22}: {user.get(k)}\")\n    p(\"username\", \"Username\")\n    p(\"full_name\", \"Full name\")\n    p(\"userID\", \"User ID\")\n    p(\"is_private\", \"Private\")\n    p(\"is_verified\", \"Verified\")\n    p(\"is_business\", \"Business\")\n    p(\"follower_count\", \"Followers\")\n    p(\"following_count\", \"Following\")\n    p(\"media_count\", \"Posts\")\n    if user.get(\"external_url\"):\n        print(f\"{'External URL':22}: {user.get('external_url')}\")\n    bio = user.get(\"biography\")\n    if bio:\n        print(f\"{'Biography':22}:\\n\")\n        for line in bio.splitlines():\n            print(f\"  {line}\")\n    hd = user.get(\"hd_profile_pic_url_info\", {}) if isinstance(user.get(\"hd_profile_pic_url_info\"), dict) else {}\n    if hd.get(\"url\"):\n        print(f\"{'Profile picture':22}: {hd.get('url')}\")\n    if user.get(\"public_email\"):\n        print(f\"{'Public email':22}: {user.get('public_email')}\")\n    if user.get(\"public_phone_number\") or user.get(\"public_phone_country_code\"):\n        ph = format_phone(user.get(\"public_phone_country_code\", \"\"), user.get(\"public_phone_number\", \"\"))\n        if ph:\n            print(f\"{'Public phone':22}: {ph}\")\n    print(\"=\" * 28)\n\ndef interactive_user_menu_full(user_raw, sessionid, cookie_dict, web_raw=None, lookup_raw=None, feed_raw=None, feed_media_meta=None):\n    feed_info = infer_locations_from_feed(feed_raw) if feed_raw else {\"locations\": [], \"last_post_ts\": None}\n    linked = gather_linked_accounts(user_raw, lookup_raw)\n    pic_infos = extract_profile_picture_info(user_raw or web_raw or lookup_raw, sessionid)\n\n    while True:\n        print(\"\\nSelect an option:\")\n        print(\"  1) Account Summary\")\n        print(\"  2) View Full Raw JSON (private API / user object)\")\n        print(\"  3) View Web Profile JSON (web_profile_info)\")\n        print(\"  4) Advanced Lookup (raw)\")\n        print(\"  5) Recent Media & Locations\")\n        print(\"  6) Extended Investigator\")\n        print(\"  7) View Cookies\")\n        print(\"  8) Exit to previous menu\")\n        choice = input(\"Enter choice [1-8]: \").strip()\n        if choice == \"1\":\n            print_account_summary(user_raw)\n        elif choice == \"2\":\n            pretty_print_json(user_raw, label=\"User JSON (private API)\")\n        elif choice == \"3\":\n            pretty_print_json(web_raw, label=\"Web profile JSON\")\n        elif choice == \"4\":\n            pretty_print_json(lookup_raw, label=\"Advanced lookup JSON\")\n        elif choice == \"5\":\n            if not feed_raw or not isinstance(feed_raw, dict):\n                print(\"[!] No feed data available.\")\n                continue\n            items = feed_raw.get(\"items\") or []\n            print(f\"\\nRecent media count shown: {len(items)} (first {min(12, len(items))})\")\n            for idx, it in enumerate(items[:12]):\n                taken = it.get(\"taken_at\") or it.get(\"device_timestamp\")\n                t_iso = epoch_to_iso(taken) if taken else \"unknown\"\n                caption = None\n                if isinstance(it.get(\"caption\"), dict):\n                    caption = it[\"caption\"].get(\"text\")\n                media_id = it.get(\"id\") or it.get(\"pk\")\n                print(f\"\\n[{idx+1}] id: {media_id}\")\n                print(f\"    taken_at: {t_iso}\")\n                if it.get(\"location\"):\n                    loc = it.get(\"location\")\n                    print(f\"    location: {loc.get('name')}  (lat:{loc.get('lat')}, lng:{loc.get('lng')})\")\n                display_url = None\n                if isinstance(it.get(\"image_versions2\"), dict):\n                    candidates = it[\"image_versions2\"].get(\"candidates\", [])\n                    if candidates:\n                        display_url = candidates[0].get(\"url\")\n                if not display_url and isinstance(it.get(\"carousel_media\"), list) and it[\"carousel_media\"]:\n                    cm = it[\"carousel_media\"][0]\n                    if isinstance(cm.get(\"image_versions2\"), dict):\n                        display_url = cm[\"image_versions2\"].get(\"candidates\", [{}])[0].get(\"url\")\n                if display_url:\n                    print(f\"    media_url: {display_url}\")\n                    if feed_media_meta and media_id and media_id in feed_media_meta:\n                        print(f\"    media_head: {feed_media_meta[media_id]}\")\n                if caption:\n                    print(f\"    caption: {caption[:160] + ('...' if len(caption) > 160 else '')}\")\n        elif choice == \"6\":\n            print(\"\\n=== Extended Investigator ===\")\n            print(\"\\n- Linked / Connected Accounts & Contacts -\")\n            if any(linked.values()):\n                if linked.get(\"connected_accounts\"):\n                    print(\"Connected accounts:\")\n                    pretty_print_json(linked.get(\"connected_accounts\"))\n                if linked.get(\"facebook_pages\"):\n                    print(\"Facebook pages / FB data:\")\n                    pretty_print_json(linked.get(\"facebook_pages\"))\n                if linked.get(\"external_urls\"):\n                    print(\"External URLs:\")\n                    for u in linked.get(\"external_urls\"):\n                        print(\"  - \" + u)\n                if linked.get(\"emails\"):\n                    print(\"Emails (raw / obfuscated if present):\")\n                    for e in linked.get(\"emails\"):\n                        print(\"  - \" + str(e))\n                if linked.get(\"phones\"):\n                    print(\"Phones (raw / obfuscated if present):\")\n                    for p in linked.get(\"phones\"):\n                        print(\"  - \" + str(p))\n            else:\n                print(\"No linked accounts / contacts detected in returned JSON.\")\n            print(\"\\n- Activity / Last-seen heuristics -\")\n            last_active = try_get_last_active(user_raw, feed_info)\n            if last_active:\n                print(f\"Last activity (heuristic): {last_active}\")\n            else:\n                print(\"No explicit last-active info; no recent posts found to infer last activity.\")\n            print(\"\\n- Recent media locations (inferred) -\")\n            if feed_info.get(\"locations\"):\n                for loc in feed_info[\"locations\"]:\n                    print(f\"  - {loc.get('name')} (pk={loc.get('pk')}) lat={loc.get('lat')} lng={loc.get('lng')}\")\n            else:\n                print(\"  No locations found in recent media items.\")\n            print(\"\\n- Profile picture & CDN metadata -\")\n            if pic_infos:\n                for p in pic_infos:\n                    print(f\"  url: {p.get('url')}\")\n                    if p.get(\"head\"):\n                        print(f\"    final_url: {p['head'].get('final_url')}\")\n                        print(f\"    status: {p['head'].get('status_code')}  content-type: {p['head'].get('content_type')}  size: {p['head'].get('content_length')}\")\n                        print(f\"    last_modified: {p['head'].get('last_modified')}  etag: {p['head'].get('etag')}\")\n                    else:\n                        print(\"    (HEAD request failed or not available)\")\n            else:\n                print(\"  No profile picture URL discovered in returned JSON.\")\n            print(\"\\n- Raw sources available -\")\n            if web_raw:\n                print(\"web_profile_info: available\")\n            if lookup_raw:\n                print(\"advanced_lookup: available\")\n            if feed_raw:\n                print(\"feed/user: available\")\n            print(\"=== End Investigator ===\")\n        elif choice == \"7\":\n            print(\"\\n=== Cookies ===\")\n            if not cookie_dict:\n                print(\"No cookies available.\")\n            else:\n                for name, value in cookie_dict.items():\n                    label = label_cookie_name(name)\n                    print(f\"{name:20} ({label}) = {value}\")\n        elif choice == \"8\":\n            break\n        else:\n            print(\"[!] Invalid choice. Enter 1-8.\")\n\n# ---- Login & main flows ----\n\ndef do_login_interactive():\n    colorPrint(CYAN, \"[*] Session ID Grabber with 2FA\\n\")\n    username = input(f\"[+] Enter Username: \").strip()\n    password = stdiomask.getpass(f\"[+] Enter Password: \").strip()\n\n    s = requests.Session()\n    headers = {\n        \"Host\": \"i.instagram.com\",\n        \"X-Ig-Connection-Type\": \"WiFi\",\n        \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n        \"X-Ig-Capabilities\": \"36r/Fx8=\",\n        \"User-Agent\": \"Instagram 159.0.0.28.123 (iPhone8,1; iOS 14_1)\",\n        \"X-Ig-App-Locale\": \"en\",\n        \"Accept-Encoding\": \"gzip, deflate\",\n    }\n\n    device_id = str(uuid4())\n    phone_id = str(uuid4())\n\n    data = {\n        \"username\": username,\n        \"reg_login\": \"0\",\n        \"enc_password\": f\"#PWD_INSTAGRAM:0:&:{password}\",\n        \"device_id\": device_id,\n        \"login_attempt_count\": \"0\",\n        \"phone_id\": phone_id,\n    }\n\n    stop_event = threading.Event()\n    anim_thread = threading.Thread(target=animate_loading, args=(stop_event,), daemon=True)\n\n    try:\n        stop_event.clear()\n        anim_thread.start()\n        try:\n            r = s.post(LOGIN_URL, headers=headers, data=data, timeout=30)\n        except Exception as e:\n            stop_event.set()\n            colorPrint(RED, \"\\n\\n[!] Network error during login request:\", str(e))\n            return None, None\n        stop_event.set()\n        anim_thread.join(timeout=0.5)\n\n        text = r.text or \"\"\n        j = safe_json(r)\n\n        if 'The password you entered is incorrect' in text or 'bad_password' in text.lower() or \\\n           (isinstance(j, dict) and j.get('status') == 'fail' and 'password' in j.get('message', '').lower()):\n            colorPrint(RED, \"\\n\\n[!] Wrong password.\")\n            input(\"[+] Press Enter to exit...\")\n            return None, None\n\n        two_factor_required = False\n        two_factor_identifier = None\n        if isinstance(j, dict) and (j.get(\"two_factor_required\") or j.get(\"two_factor_info\")):\n            two_factor_required = True\n            info = j.get(\"two_factor_info\") or {}\n            two_factor_identifier = info.get(\"two_factor_identifier\") or j.get(\"two_factor_identifier\")\n        elif \"two_factor_required\" in text or \"two_factor\" in text:\n            m = re.search(r'\"two_factor_identifier\"\\s*:\\s*\"([^\"]+)\"', text)\n            if m:\n                two_factor_required = True\n                two_factor_identifier = m.group(1)\n\n        if two_factor_required:\n            colorPrint(YELLOW, \"\\n\\n[+] Two-factor authentication required.\")\n            if two_factor_identifier:\n                print(f\"    two_factor_identifier: {two_factor_identifier}\")\n            else:\n                print(\"    (no two_factor_identifier found; we'll still attempt submission)\")\n\n            stop_event.clear()\n            anim_thread = threading.Thread(target=animate_loading, args=(stop_event,), daemon=True)\n            anim_thread.start()\n            code = input_with_timeout(f\"\\nEnter 2FA code (you have {OTP_TIMEOUT} seconds): \", OTP_TIMEOUT, stop_event)\n            stop_event.set()\n            anim_thread.join(timeout=0.5)\n\n            if not code:\n                colorPrint(RED, \"\\n\\n[!] No 2FA code entered (timed out). Exiting.\")\n                input(\"[+] Press Enter to exit...\")\n                return None, None\n\n            two_data = {\n                \"username\": username,\n                \"verification_code\": code,\n                \"verificationCode\": code,\n                \"device_id\": device_id,\n                \"phone_id\": phone_id,\n                \"trust_this_device\": \"1\",\n            }\n            if two_factor_identifier:\n                two_data[\"two_factor_identifier\"] = two_factor_identifier\n\n            stop_event.clear()\n            anim_thread = threading.Thread(target=animate_loading, args=(stop_event,), daemon=True)\n            anim_thread.start()\n            try:\n                r2 = s.post(TWO_FACTOR_URL, headers=headers, data=two_data, timeout=OTP_TIMEOUT)\n            except Exception as e:\n                stop_event.set()\n                colorPrint(RED, \"\\n\\n[!] Network error during 2FA request:\", str(e))\n                return None, None\n            stop_event.set()\n            anim_thread.join(timeout=0.5)\n\n            j2 = safe_json(r2)\n            text2 = r2.text or \"\"\n            success = False\n            if 'logged_in_user' in text2:\n                success = True\n            elif isinstance(j2, dict) and (j2.get(\"status\") == \"ok\" and j2.get(\"logged_in_user\")):\n                success = True\n            cookie_dict_after = s.cookies.get_dict()\n            if not success and any(label_cookie_name(n) == \"session\" for n in cookie_dict_after.keys()):\n                success = True\n\n            if success:\n                colorPrint(GREEN, \"\\n\\n[+] Logged In Success (2FA).\")\n            else:\n                colorPrint(RED, \"\\n\\n[!] 2FA response did not indicate success. Full response below:\")\n                pretty_print_json(j2, label=\"2FA response JSON\")\n                displayed = text2[:1500] + (\"...\" if len(text2) > 1500 else \"\")\n                print(\"\\n(truncated raw text):\")\n                print(displayed)\n                input(\"[+] Press Enter to exit...\")\n                return None, None\n\n        else:\n            if 'logged_in_user' in text or (isinstance(j, dict) and j.get(\"status\") == \"ok\" and j.get(\"logged_in_user\")):\n                colorPrint(GREEN, \"\\n\\n[+] Logged In Success.\")\n            else:\n                colorPrint(RED, \"\\n\\n[!] Login response did not clearly indicate success. Full response JSON below:\")\n                pretty_print_json(j, label=\"Login response JSON\")\n                displayed = text[:1500] + (\"...\" if len(text) > 1500 else \"\")\n                print(\"\\n(truncated raw text):\")\n                print(displayed)\n                input(\"[+] Press Enter to exit...\")\n                return None, None\n\n        colorPrint(CYAN, \"\\n\\nCookies found:\")\n        cookie_dict = s.cookies.get_dict()\n        if not cookie_dict:\n            print(\"  No cookies found in session.\")\n        else:\n            for name, value in cookie_dict.items():\n                label = label_cookie_name(name)\n                print(f\"  - {name} ({label}) = {value}\")\n\n        return s, cookie_dict\n\n    finally:\n        try:\n            stop_event.set()\n        except Exception:\n            pass\n\ndef prompt_and_scrape(session_cookies):\n    yn = input(\"\\n[?] Do you want to scrape an account using the session id? (y/N): \").strip().lower()\n    if yn != \"y\":\n        colorPrint(CYAN, \"[*] Exiting.\")\n        return\n\n    sessionid = session_cookies.get(\"sessionid\")\n    if not sessionid:\n        for k, v in session_cookies.items():\n            if label_cookie_name(k) in (\"session\", \"instagram\"):\n                sessionid = v\n                break\n\n    if not sessionid:\n        sessionid = input(f\"{RED}[!] No sessionid cookie found automatically. Enter sessionid manually: {RESET}\").strip()\n        if not sessionid:\n            colorPrint(RED, \"[!] No sessionid provided. Cannot proceed.\")\n            return\n\n    target = input(\"[+] Enter target username or numeric id: \").strip()\n    if not target:\n        colorPrint(RED, \"[!] No target provided. Exiting.\")\n        return\n\n    if target.isdigit():\n        search_type = \"id\"\n        user_id = target\n        username = None\n    else:\n        search_type = \"username\"\n        username = target\n        user_id = None\n\n    web_raw = None\n    user_raw = None\n    lookup_raw = None\n    feed_raw = None\n    feed_media_meta = {}\n\n    # Try to resolve user_id for a username using multiple fallbacks\n    if username and not user_id:\n        user_id, source, raw_used = resolve_user_id(username, sessionid)\n        if user_id:\n            colorPrint(GREEN, f\"[+] Resolved username '{username}' -> user_id {user_id} (source: {source})\")\n            if source == \"web_profile_info\":\n                web_raw = raw_used\n            elif source == \"users/lookup\":\n                lookup_raw = raw_used\n            elif source == \"usernameinfo\":\n                web_raw = raw_used\n            elif source == \"www_profile_a1\":\n                web_raw = raw_used\n        else:\n            colorPrint(RED, f\"[!] Could not resolve user id for '{username}' from available endpoints.\")\n            # Show what each endpoint returned for debugging (non-fatal)\n            print(\"[*] Showing quick diagnostics (web_profile_info, usernameinfo, lookup, www_profile_a1):\")\n            try:\n                diagnostics = {}\n                d = get_user_web_profile(username, sessionid)\n                diagnostics['web_profile_info'] = d.get(\"raw\") or d.get(\"error\")\n                e = do_advanced_lookup(username, sessionid)\n                diagnostics['lookup'] = e.get(\"raw\") or e.get(\"raw_text\") or e.get(\"error\")\n                f = get_usernameinfo(username, sessionid)\n                diagnostics['usernameinfo'] = f.get(\"raw\") or f.get(\"error\")\n                g = get_www_profile_a1(username)\n                diagnostics['www_profile_a1'] = g.get(\"raw\") or g.get(\"text\") or g.get(\"error\")\n                pretty_print_json(diagnostics, label=\"diagnostics\")\n            except Exception:\n                pass\n            return\n\n    # proceed to fetch private info, feed, lookup etc if we have user_id\n    if user_id:\n        stop = threading.Event(); t = threading.Thread(target=animate_loading, args=(stop,), daemon=True)\n        stop.clear(); t.start()\n        user_info_res = get_user_info_private(user_id, sessionid)\n        stop.set(); t.join(timeout=0.5)\n        user_raw = user_info_res.get(\"raw\") or user_info_res.get(\"error\")\n\n        stop = threading.Event(); t = threading.Thread(target=animate_loading, args=(stop,), daemon=True)\n        stop.clear(); t.start()\n        lookup_res = do_advanced_lookup(username or user_raw.get(\"username\", \"\"), sessionid)\n        stop.set(); t.join(timeout=0.5)\n        lookup_raw = lookup_res.get(\"raw\") or lookup_res.get(\"raw_text\")\n\n        stop = threading.Event(); t = threading.Thread(target=animate_loading, args=(stop,), daemon=True)\n        stop.clear(); t.start()\n        feed_res = get_feed_media(user_id, sessionid, count=12)\n        stop.set(); t.join(timeout=0.5)\n        feed_raw = feed_res.get(\"raw\") or {}\n\n        # gather media HEAD info for first items\n        try:\n            items = feed_raw.get(\"items\") or []\n            for it in items[:12]:\n                media_id = it.get(\"id\") or it.get(\"pk\")\n                display_url = None\n                if isinstance(it.get(\"image_versions2\"), dict):\n                    candidates = it[\"image_versions2\"].get(\"candidates\", [])\n                    if candidates:\n                        display_url = candidates[0].get(\"url\")\n                if not display_url and isinstance(it.get(\"carousel_media\"), list) and it[\"carousel_media\"]:\n                    cm = it[\"carousel_media\"][0]\n                    if isinstance(cm.get(\"image_versions2\"), dict):\n                        display_url = cm[\"image_versions2\"].get(\"candidates\", [{}])[0].get(\"url\")\n                if display_url and media_id:\n                    hdr = head_request_headers(display_url, cookies={'sessionid': sessionid})\n                    feed_media_meta[media_id] = hdr\n        except Exception:\n            pass\n\n        # normalize and ensure user_raw is a dict for summary\n        if isinstance(user_raw, dict) and user_raw.get(\"user\"):\n            # some responses return wrapper { \"user\": { ... } }\n            if isinstance(user_raw.get(\"user\"), dict):\n                user_raw = user_raw[\"user\"]\n        if not isinstance(user_raw, dict):\n            colorPrint(RED, \"[!] Unexpected user object received; showing raw JSONs for inspection.\")\n            pretty_print_json(user_raw, label=\"User raw\")\n            return\n        if \"username\" not in user_raw and username:\n            user_raw[\"username\"] = username\n        if \"userID\" not in user_raw and user_id:\n            user_raw[\"userID\"] = str(user_id)\n\n        interactive_user_menu_full(user_raw, sessionid, session_cookies, web_raw=web_raw, lookup_raw=lookup_raw, feed_raw=feed_raw, feed_media_meta=feed_media_meta)\n\ndef main():\n    s, cookies = do_login_interactive()\n    if s is None:\n        return\n    prompt_and_scrape(cookies)\n    colorPrint(GREEN, \"\\n[+] Done. Press Enter to exit...\")\n\nif __name__ == \"__main__\":\n    main()\n" > $HOME/BrokerOSNIT/BrokerOSNIT.py && chmod +x $HOME/BrokerOSNIT/BrokerOSNIT.py $HOME/BrokerOSNIT/LocalOSNIT.py && mkdir -p $HOME/bin && if ! grep -q 'export PATH="$HOME/bin:$PATH"' $HOME/.bashrc; then echo 'export PATH="$HOME/bin:$PATH"' >> $HOME/.bashrc; fi && source $HOME/.bashrc && ln -sf $HOME/BrokerOSNIT/BrokerOSNIT.py $HOME/bin/BrokerOSNIT.py && ln -sf $HOME/BrokerOSNIT/LocalOSNIT.py $HOME/bin/LocalOSNIT.py

```
